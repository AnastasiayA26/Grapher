operators = (
    ## lowest priority
    # ('ternary', ('?', ':')),
    # ('lassoc', '||'),
    # ('lassoc', '&&'),
    ('lassoc', '|'),
    ('lassoc', '^'),
    ('lassoc', '&'),
    ('nonassoc', '==', '!=', '<=', '>=', '<', '>'),
    # ('lassoc', '<<', '>>'),
    ('lassoc', '+', '-'),
    ('lassoc', '*', '/', '%'),
    # ('rassoc', '**'),
    ('unary', '+', '-', '*', '&', '!', '~'),
    # ('unary', '++', '--'),
    # ('unary_postfix', '++', '--'),
    ## highest priority
)

rule_name_start = 'expr'
rule_name_end = 'expr_others'

dq = lambda s: f'"{s}"'

print(''.center(60, '#'))
print(' START OF AUTOGENERATED GRAMMAR '.center(60, '#'))
print(f'# generated by generate_operators.py')

print(f'?{rule_name_start}: expr_{0}')
for i, (assoc, *ops) in enumerate(operators):
    cur = f'expr_{i}'
    nxt = f'expr_{i+1}'
    if assoc == 'ternary':
        print(f'?{cur}: {cur}_{0}')
        for j, (op1, op2) in enumerate(ops):
            nxt_subrule = f'{cur}_{j+1}' if j + 1 < len(ops) else nxt
            print(f'?{cur}_{j}: {assoc}{{{nxt_subrule}, OP_{i}_{j}_0, OP_{i}_{j}_1}}')
            print(f'OP_{i}_{j}_0: {dq(op1)}')
            print(f'OP_{i}_{j}_1: {dq(op2)}')
    else:
        print(f'?{cur}: {assoc}{{{cur}, {nxt}, OP_{i}}}')
        options = ' | '.join(map(dq, ops))
        print(f'OP_{i}: {options}')
print(f'?expr_{len(operators)}: {rule_name_end}')

print(' END OF AUTOGENERATED GRAMMAR '.center(60, '#'))
print(''.center(60, '#'))
